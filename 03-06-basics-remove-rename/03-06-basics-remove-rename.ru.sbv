0:00:00.279,0:00:05.218
До этого мы рассматривали только добавление файлов проект. Теперь посмотрим что с удалением.

0:00:05.620,0:00:09.929
Сейчас я нахожусь на одном из предыдущих состояний проекта и удалять буду ".gitignore"

0:00:10.389,0:00:16.049
Строка ".idea" когда-то была добавлена сюда, чтобы игнорировать служебные файлы и редактора Webstorm.

0:00:16.330,0:00:22.020
Однако, по-хорошему, это игнорирование должно быть прописано совсем не здесь, а в глобальным игнор-файле.

0:00:22.570,0:00:27.150
Поскольку выбор редактора - это моя инициатива, она не относится вообще к данному проекту.

0:00:27.540,0:00:32.460
Если у меня другие проекты где-то, то в них тоже нужно будет игнорировать ".idea".

0:00:32.680,0:00:35.520
В общем, определенно эта настройка должна быть глобальной.

0:00:35.520,0:00:42.020
Поэтому давайте сейчас настрою глобальный игнор-файл, открою его в редакторе и помещу его туда.

0:00:42.120,0:00:49.280
Закрываю и возвращаюсь обратно к проекту. теперь локальный файл ".gitignore" мне не нужен, и давайте я его удалю.

0:00:50.700,0:00:52.700
Ну-ка "git status".

0:00:52.810,0:00:57.510
Напомню, что индекс хранит список всех файлов проекта, которые сейчас отслеживаются Git'ом.

0:00:57.880,0:01:03.359
И здесь у нас сейчас файл пропал, а в индексе он есть, и "git status" это, разумеется, заметил.

0:01:04.860,0:01:12.380
Чтобы сохранить это изменение в репозитории, нужно сначала добавить его в индекс. Для этого как ранее воспользуемся команды "git add".

0:01:13.480,0:01:17.640
Здесь немножко забавно, потому что на самом деле файла ".gitignore" уже нет.

0:01:18.040,0:01:23.580
И "git add" and добавляет в индекс как бы факт его удаления, а если быть ближе в технической сути

0:01:23.770,0:01:29.490
происходящего, то просто удаляет ".gitignore" из списка файлов в индексе. Теперь, если я запущу "git status",

0:01:30.040,0:01:34.859
то мы видим, что изменение перекочевало из статуса "not staged for commit"

0:01:35.520,0:01:42.080
В статус "to be committed". То есть изменение в индексе, и сейчас можем окончательно зафиксировать его в репозитории.

0:01:42.320,0:01:46.160
"git commit -m Cleanup"

0:01:46.160,0:01:51.000
Так как сообщение здесь из одного слова, то кавычки не нужны. Обратите внимание: небольшая особенность рисунка.

0:01:51.000,0:01:59.720
В репозитории этот файл на самом деле по-прежнему есть, потому что репозитории хранит всю историю изменений.

0:01:59.980,0:02:04.920
Просто на данной конкретной иллюстрации показывается последнее состояние репозитория.

0:02:05.140,0:02:10.440
А то, что было, оно где-то там сзади за ним. Мы позже посмотрим как получить к этому доступ.

0:02:11.040,0:02:17.160
Для удаления файлов в Git существует также команда "git rm". И здесь мы указать один или несколько путей.

0:02:17.800,0:02:25.300
Если указываю директорию, то нужен флажок "-r", например, вот так вот, для удаления директории "src".

0:02:25.680,0:02:29.920
Эта команда осуществляет в одну операцию то, что мы с вами делали в две,

0:02:30.300,0:02:35.120
то есть она удаляет одновременно из рабочей директории и добавляет это изменение в индекс.

0:02:35.620,0:02:38.459
"git rm" - это то же самое, что просто удаление

0:02:39.880,0:02:44.699
плюс "git add", то есть состояние проекта, если я её запущу, будет вот таким.

0:02:45.780,0:02:52.820
Впрочем, обычное удаление уже видели, поэтому давайте я запущу и не в таком варианте, а с ключиком "--cached".

0:02:53.400,0:03:00.560
Он удалит из индекса но оставит рабочем каталоге.Теперь состояние проекта стало вот таким.

0:03:01.180,0:03:06.860
Обратите внимание: если я наберу "git status", то видно, что "src" директория осталось,

0:03:06.860,0:03:13.980
потому что был ключик "--cached", но она теперь "untracked", то есть гиты и не отслеживает. Она отсутствует в индексе.

0:03:14.140,0:03:23.340
Чтобы она обратно попала в яндекс: "git add src".
Ну-ка... Ну вот. Опять изменений нет в рабочей директории,

0:03:23.820,0:03:27.300
в индексе, в текущем расстоянии репозитория одни и те же файлы.

0:03:27.440,0:03:34.479
Мы командо "git rm --cached" сначала удалили "script.js" из индекса, а потом "git add" вернули его же обратно.

0:03:34.820,0:03:36.820
Таким образом изменений нет.

0:03:37.070,0:03:44.469
На практике удаление "rm --cached" часто применяется к файлам, которые хочется оставить в рабочей директории,

0:03:44.840,0:03:46.989
Но в дальнейшем не хранить в Git.

0:03:47.450,0:03:53.350
Например, потому что эти файлы служебные и были добавлены по ошибке. Для этого их после удаления вносят в ".gitignore"

0:03:54.320,0:03:58.820
Замечу, что флаг "--cached" используется и в некоторых других командах Git.

0:03:58.900,0:04:03.560
Его общий смысл в том, что операция производится только с индексом вместо рабочей директории.

0:04:05.090,0:04:11.950
Хотелось бы обратить ваше внимание на еще один аспект работы команды "rm",  который свойственен и многим другим командам Git.

0:04:12.820,0:04:19.660
Git старается действует безопасно, то есть если у меня есть какие-то изменения, и я это изменение еще не сохранил в репозитории,

0:04:19.840,0:04:24.320
то попытка такой файл удалить: "git rm", приведет к ошибке

0:04:24.580,0:04:30.240
Git ругается, потому что если сейчас провести удаление, то не сохраненные изменения просто пропадут.

0:04:30.770,0:04:38.079
Они не были записаны в репозиторий, так что гид не сможет помочь с их восстановлением, если окажется, что мы удалили по ошибке,

0:04:38.720,0:04:41.470
и таким образом он обращает наше внимание на это.

0:04:42.260,0:04:48.820
Если мы действительно хотим удалить такой файл, то мы воспользуемся еще одним флагом общего назначения: "-f".

0:04:48.820,0:04:55.940
Этот флаг есть во многих командах Git. Он позволяет игнорировать предупреждение и все-таки заставить git совершить операцию.

0:04:56.200,0:05:02.860
Так что если я сейчас это запущу, то "index.html" будет удален из рабочей директории и из индекса.

0:05:04.040,0:05:08.680
Итак, мы с вами рассматривали добавление файла в репозиторий, удаление файлов.

0:05:09.350,0:05:15.339
Осталось переименование. С ним проще всего, потому что с точки зрения Git переименования вообще не существует.

0:05:16.260,0:05:20.020
Например, возьму и "index.html" переименую в "hello.html".

0:05:20.640,0:05:24.140
Теперь, если я наберу "git status", то видно два изменения.

0:05:24.820,0:05:33.720
Первое: старый файл "index.html" был удален. И второе: появился новый неизвестный Git'у файл с именем "hello.html".

0:05:33.720,0:05:41.060
То есть переименование было воспринято Git'ом как совокупность двух операций: удаление старого файла и создание нового

0:05:41.380,0:05:48.560
Теперь добавим оба этих изменения в индекс: 
"git add ." 
И еще раз запустим "git status".

0:05:49.120,0:05:52.080
Теперь "git status" уже видит, что, ага, было переименование.

0:05:52.900,0:05:57.689
Почему же она не могла сказать об этом ранее в момент предыдущего вызова "git status"?

0:05:58.540,0:06:03.629
Да просто потому, что на момент того вызова файл "hello.html" был неизвестен.

0:06:03.880,0:06:08.939
Git не знал, что там внутри находится и, соответственно, не мог понять, что это один и тот же файл.

0:06:09.070,0:06:13.650
А когда мы добавляем файл в индекс, то Git записывает его в свои внутренние структуры,

0:06:13.900,0:06:20.789
считает при этом контрольную сумму и может понять, что у него такой файл уже есть и вывести такое вот красивое сообщение.

0:06:21.880,0:06:26.670
Соответственно, если сделаю сейчас "git commit", то это изменение будет записано в репозиторий.

0:06:27.310,0:06:31.110
Как и в случае с "rm" в Git есть специальная команда "git mv",

0:06:31.510,0:06:38.039
которая позволяет сделать эти обе операции одновременно, то есть, например, "git mv index.html hello.html".

0:06:38.770,0:06:43.829
Одновременно переименовала бы файл в рабочей директории и добавила бы информацию об этом в индекс.

0:06:45.010,0:06:50.069
Итак, в этом выпуске мы рассмотрели как происходит удаление и переименование файлов Git.

0:06:50.680,0:06:56.700
Общий вывод такой: что и удаление, и переименование файлов не требует каких-то особых команд.

0:06:56.700,0:07:01.040
Можно просто сделать это в рабочей директории и добавить изменение через "git add".

0:07:01.200,0:07:05.909
И все будет хорошо. Но тем не менее для большего удобства существуют готовые команды.

0:07:06.580,0:07:13.199
"git rm" удаляет файлы и из рабочей директории, и из индекса. То есть это сочетание обычного удаления файла с диска

0:07:13.450,0:07:15.929
плюс добавление информации об этом "git add".

0:07:16.900,0:07:20.400
Самый частый флаг - это, пожалуй, "-r" для удаления директорий.

0:07:20.950,0:07:25.979
"-f" для удаления файлов с изменениями, которые не были сохранены в репозитории.

0:07:26.320,0:07:29.810
При этом надо иметь ввиду, что все  несохранённые изменения  будут потеряны,

0:07:30.020,0:07:38.080
потому что что мы не сохранили в Git, то потом из него нельзя достать. Так что если мы хотим иметь возможность позже откатить удаление,

0:07:38.080,0:07:42.080
то лучше сначала закомитить изменения, а потом уже файл удалять.

0:07:43.020,0:07:46.009
И "--cached" для удаления только из индекса.

0:07:46.220,0:07:51.480
Этот флаг используется, когда мы хотим файл из репозитория ударить, а в рабочий директории оставить,

0:07:51.480,0:07:55.940
например, потому что он нам для чего-то еще потребуется.

0:07:55.940,0:08:01.060
Аналогично устроена команда "git mv". Она переименовывает одновременно в рабочей директории

0:08:01.320,0:08:05.320
и добавляет информацию об этом в индекс.
