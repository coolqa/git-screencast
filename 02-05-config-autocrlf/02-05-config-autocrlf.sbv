0:00:00.035,0:00:03.285
git умеет автоматически преобразовывать переводы строк.

0:00:03.285,0:00:06.285
Один из способов это настроить - это параметр конфигурации

0:00:06.285,0:00:09.235
"core.autocrlf". У него есть 3 возможных значения.

0:00:09.235,0:00:12.235
Первое - это true. Оно ориентировано,

0:00:12.235,0:00:14.575
в первую очередь на Windows системы.

0:00:14.575,0:00:17.595
Если вы установили git под Windows и оставили

0:00:17.595,0:00:20.465
это значение в инсталляторе по умолчанию,

0:00:20.465,0:00:23.365
то вам даже делать ничего не нужно, в системной конфигурации

0:00:23.365,0:00:26.405
у вас уже стоит именно оно. При этом, когда мы сохраняем

0:00:26.405,0:00:29.355
текстовый файл в git, то он осуществляет так называемую

0:00:29.355,0:00:32.555
нормализацию: двойные, "виндовые" переводы строк CR LF

0:00:32.555,0:00:35.505
заменяются на одинарные "юниксовые" LF.

0:00:35.505,0:00:38.115
В таком виде git его сохраняет у себя.

0:00:38.115,0:00:41.115
И обратно, когда мы получаем файлы из базы данных git, то

0:00:41.115,0:00:43.825
он заменяет LF на CR LF. Получается такая прозрачная

0:00:43.825,0:00:46.885
двусторонняя конвертация. Внутри git-а файлы

0:00:46.885,0:00:50.045
хранятся с LF в качестве перевода строк, но, когда мы работаем с ними,

0:00:50.045,0:00:52.815
то мы видим "виндовый" разделитель CR LF.

0:00:52.815,0:00:55.485
Теперь, если мы используем функционал git для того, чтобы

0:00:55.485,0:00:58.485
поделиться с кем-то нашими файлами, то, если этот кто-то работает на Unix

0:00:58.485,0:01:01.405
системе, то он, получив файл из нашего git-а,

0:01:01.405,0:01:03.855
увидит в них разделитель LF и будет очень рад.

0:01:04.445,0:01:07.035
А если этот кто-то работает под Windows,

0:01:07.035,0:01:08.385
то он, опять же, получит файлы с LF,

0:01:08.755,0:01:11.715
но, скорее всего, у него стоит такая же настройка.

0:01:11.715,0:01:14.575
Поэтому, когда он будет получать из хранилища git,

0:01:14.575,0:01:18.025
то уже его git автоматически заменит LF на CR LF.

0:01:18.025,0:01:21.105
То есть он увидит файлы с родным "виндовым" разделителем строк.

0:01:21.105,0:01:23.945
В итоге, все довольны. Следующий вариант называется

0:01:23.945,0:01:26.875
input. В отличие от предыдущего он предполагает

0:01:26.875,0:01:29.845
только одностороннюю конвертацию. То есть когда

0:01:29.845,0:01:33.185
мы сохраняем наш файл в git, то CR LF в нем заменяется на LF

0:01:33.455,0:01:36.505
А когда мы получаем файл из git-а, то не делается ничего.

0:01:36.815,0:01:39.415
Это отличный вариант для Unix систем, потому что

0:01:39.415,0:01:42.445
под Unix системой файл с Windows разделителем строк может

0:01:42.445,0:01:44.475
появиться только нечаянно. Например,

0:01:44.475,0:01:47.065
его скопировали напрямую с Windows в обход git-а.

0:01:47.065,0:01:49.835
И в этом случае настройка input как раз это поправит.

0:01:50.295,0:01:53.025
Замечу, что зачастую такую настройку выбирают и

0:01:53.025,0:01:55.445
те, кто работет под Windows в том случае, если

0:01:55.445,0:01:58.185
основным окружением для проекта является "юниксовая".

0:01:58.235,0:02:01.505
При этом, свой редактор они тоже перенастраивают, чтобы был LF

0:02:01.505,0:02:04.525
в качестве разделителя строк. Современные редакторы позволяют достаточно

0:02:04.525,0:02:07.115
легко это сделать. Итак, выбирая

0:02:07.115,0:02:09.835
этот вариант, вы говорите git-у, что официальным разделителем

0:02:09.835,0:02:12.905
строк в вашем проекте является LF, а CR LF

0:02:12.905,0:02:15.915
может попасть в файлы только по неосторожности

0:02:15.915,0:02:18.965
и его нужно побыстрее оттуда удалить. И, наконец,

0:02:18.965,0:02:21.995
последний вариант - это false, он же значение по умолчанию.

0:02:21.995,0:02:24.515
Этот вариант означает ничего не делать.

0:02:24.515,0:02:27.445
Это отличный выбор, когда такой проблемы не существует.

0:02:27.445,0:02:30.145
Например, когда все разработчики под Unix окружением.

0:02:30.255,0:02:32.485
Или у всех разработчиков стоит Windows.

0:02:32.485,0:02:35.095
И мы точно знаем, что так будет всегда, что

0:02:35.095,0:02:37.615
никакой кросс-платформенной разработки не планируется.

0:02:37.615,0:02:40.485
В этом случае у всех одинаковые переводы строк, и можно

0:02:40.485,0:02:43.545
оставить все, как есть. Также эту опцию выбирают очень

0:02:43.545,0:02:46.275
аккуратные люди, которые точно знают, что у них

0:02:46.275,0:02:49.175
редактор настроен правильно, с переводами строк все хорошо,

0:02:49.175,0:02:51.525
и они не хотят, чтобы git автоматически преобразовывал

0:02:51.525,0:02:54.585
что бы то ни было. При этом надо понимать, что

0:02:54.585,0:02:57.525
файл с разделителем CR LF будет сохранен в git

0:02:57.525,0:03:00.605
хранилище, как есть. Так что, если у кого-то из разработчиков

0:03:00.605,0:03:03.115
настроено autocrlf, а у кого-то - нет

0:03:03.115,0:03:05.945
или стоит false по ошибке, то в репозитории

0:03:05.945,0:03:08.715
мы получим компот из разделителей строк:

0:03:08.715,0:03:11.225
в каких-то файлах будет LF, а в каких-то CR LF.

0:03:11.925,0:03:14.915
Чтобы этого избежать, существует альтернативный способ

0:03:14.915,0:03:18.275
настройки через файл аттрибутов, который мы рассмотрим позже.

0:03:18.995,0:03:21.755
На этом все про core.autocrlf.

0:03:21.755,0:03:24.735
Но для полного понимания происходящего мы должны ответить на

0:03:24.735,0:03:27.795
еще один небольшой, но очень важный вопрос:

0:03:27.795,0:03:30.515
"в каких именно файлах git делает такую замену?"

0:03:30.705,0:03:33.455
Очевидно, что не во всех.

0:03:33.455,0:03:36.515
В git мы можем хранить самые разные файлы, как текстовые, так и бинарные.

0:03:36.515,0:03:39.555
Но, если в текстовых файлах мы можем заменять переводы строк

0:03:39.555,0:03:42.035
для кросс-платформенной разработки,

0:03:42.035,0:03:45.055
то попытка замены байт в бинарном файле, скажем, в картинке,

0:03:45.055,0:03:48.415
ее просто сломает, приведет к повреждению данных.

0:03:48.705,0:03:51.795
Но как git для конкретного файла определеяет

0:03:52.125,0:03:53.815
текстовый он или бинарный?

0:03:54.365,0:03:56.995
Может быть, у него есть какое-то магическое зеркало?

0:03:57.205,0:04:00.425
Конечно, нет! Может быть, по расширению смотрит?

0:04:00.425,0:04:03.365
Можно такое настроить, но по умолчанию тоже нет.

0:04:03.445,0:04:05.335
Он смотрит на содержимое файла.

0:04:05.875,0:04:09.255
Но на что именно? Может ли такое определение дать сбой

0:04:09.255,0:04:12.075
который приведет к тому, что текстовый файл

0:04:12.075,0:04:14.425
будет воспринят как бинарный, или наоборот.

0:04:14.945,0:04:17.645
Вопрос весьма важный, так как некорректное

0:04:17.645,0:04:20.435
определение типов файла может привести к ошибкам при

0:04:20.435,0:04:23.225
преобразовании строк. Или, в случае бинарного файла, к его

0:04:23.225,0:04:24.225
повреждению.

0:04:24.485,0:04:27.215
К сожалению, отсутствует документация на эту тему.

0:04:27.215,0:04:30.005
Но вот что говорит на эту тему исходный код самого git.

0:04:30.145,0:04:33.155
Соответствующая функция очень короткая.

0:04:33.155,0:04:36.325
Git анализирует содержимое файла и, если он видит CR

0:04:36.405,0:04:39.765
за которым не идет LF, то он считает, что файл бинарный.

0:04:39.765,0:04:43.225
Действительно, в Unix системах перевод строк обычно кодируется LF.

0:04:43.475,0:04:46.225
В Windows системах - CR LF.

0:04:46.225,0:04:48.935
А если CR, за которым LF нету, то для текстового

0:04:48.935,0:04:52.045
файла это странно. Наверное, он бинарный, - считает git.

0:04:52.045,0:04:54.815
Или, если в файле есть нулевой байт.

0:04:54.815,0:04:57.985
В текстовых файлах он, как правило, не встречается. Значит, файл бинарный.

0:04:58.185,0:05:01.305
И, наконец, git считает, что в текстовых файлах количество

0:05:01.305,0:05:04.735
печатных символов должно примерно в 128 или более раз

0:05:04.935,0:05:06.815
превышать количество непечатных.

0:05:07.165,0:05:10.075
Соответственно, если это соотношение нарушается, то тоже

0:05:10.075,0:05:13.545
файл бинарный. В ином случае файл считается текстовым.

0:05:13.895,0:05:15.745
Такая вот немудреная логика.

0:05:16.155,0:05:19.085
На практике она весьма надежна, хотя, конечно, иногда и может дать

0:05:19.085,0:05:21.945
сбой, поэтому есть способ явно задать бинарность

0:05:21.945,0:05:24.585
или текстовость файла при помощи

0:05:24.585,0:05:27.605
аттрибутов. Мы поговорим об этом в одном из следующих выпусков.

0:05:27.605,0:05:30.595
На будущее, чтобы не было путаницы, замечу,

0:05:30.595,0:05:33.615
что эта функция используется для различения текстовых и бинарных

0:05:33.615,0:05:36.655
файлов только в целях преобразования переводов строк.

0:05:36.915,0:05:39.845
В git есть другая функция похожего назначения,

0:05:39.845,0:05:43.035
которая используется для сравнений, слияний и так далее,

0:05:43.035,0:05:46.055
и там просто проверяется, есть ли среди первых

0:05:46.055,0:05:48.855
8 тысяч байт хоть один нулевой.

0:05:48.855,0:05:51.395
Если "да", то данные бинарные, если "нет", то текстовые.
