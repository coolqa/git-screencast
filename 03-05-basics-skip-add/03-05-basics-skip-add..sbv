0:00:00.069,0:00:07.078
Всем привет. Ранее мы рассмотрели двухступенчатый способ сохранения данных в git. То есть сначала добавляем изменения: "git add"

0:00:07.290,0:00:13.170
в индекс, и затем сохраняем: "git commit". Однако, часто возникает вопрос: "А можно-ли попроще, побыстрее?"

0:00:13.420,0:00:18.560
Обойтись без "git add" и сразу записать изменения в репозиторий. В простых случаях вполне можно.

0:00:19.120,0:00:24.900
Начнем с такой типичной ситуации. Я зашел в проект с чистым статусом, то есть без изменений.

0:00:25.500,0:00:30.040
И затем поправил несколько файлов. Внёс изменения сюда и, скажем, вот сюда.

0:00:30.580,0:00:32.580
Переименовал функцию hello на helloGitty.

0:00:33.180,0:00:36.960
Теперь, если посмотреть статус, вот они, наши непроиндексированые изменения.

0:00:36.960,0:00:44.180
Для того, чтобы их сохранить, можно вызвать "git commit" с флагом "--all" или коротко "-a". И давайте тут же сообщение.

0:00:44.520,0:00:48.400
"-m" можно отдельно или можно одновременно указать, например, вот такое.

0:00:48.820,0:00:53.520
флаг "-a" заставит команду commit взять все изменения из рабочей директории,

0:00:53.980,0:00:57.080
внести их в индекс и тут же записать в репозиторий.

0:00:57.080,0:01:04.000
То есть, получается, как бы два в одном: и добавил в индекс, и сохранил. 
Но при этом есть важное ограничение:

0:01:04.000,0:01:15.320
"-a" игнорирует файлы, которые не отслеживаются гитом. То есть если я сейчас создам файл, скажем, "new.html" и потом посмотрю "git status" - вот у меня новый файл.

0:01:15.320,0:01:20.640
"git commit -a". Вы видите, ничего не произошло. Это потому, что файл не отслеживается.

0:01:21.060,0:01:28.500
Иными словами, флаг "-a" добавляет к коммиту предварительную стадию, на которой он вносит в индекс все изменения из рабочей директории,

0:01:28.720,0:01:33.179
но лишь для тех файлов, которые в индексе уже есть. В нашем случае вот для этих.

0:01:33.549,0:01:39.389
А потом с обновленным индексом осуществляется обычный коммит. Это очень удобно, когда зашел в проект с чистым статусом,

0:01:39.729,0:01:43.739
сделал изменения в уже существующих файлах и хочется их по-быстрому сохранить.

0:01:45.610,0:01:50.099
Сейчас я вернулся к предыдущему состоянию проекта. Мы рассмотрим еще одну ситуацию.

0:01:50.350,0:01:56.880
А именно когда у нас есть в проекте изменения, например, здесь какая-то работа идет, здесь какая-то работа тоже идет,

0:01:57.070,0:02:00.029
возможно, какие-то изменения уже добавлены даже в индекс.

0:02:00.720,0:02:05.280
И тут нам понадобилось открыть какой-нибудь третий файл, добавить туда какие-то изменения,

0:02:05.400,0:02:10.820
например, заигнорить все лог-файлы и тут же закоммитить, например, потому что это изменение очень важно,

0:02:11.050,0:02:14.399
исправляет какую-то опечатку, и необходимо побыстрее внести его в проект.

0:02:14.940,0:02:22.380
То есть вот у меня ситуация: есть изменение в рабочей директории, есть изменения в индексе, но закоммитить я хочу прямо сейчас вот это.

0:02:22.980,0:02:27.020
нет ничего проще: "git commit", параметры разные

0:02:27.300,0:02:33.440
и указываешь путь. В нашем случае это единственный файл. Но можно указать много путей, в том числе директории, и, вуаля.

0:02:33.960,0:02:39.140
Коммит берет изменения по указанным путям, добавляет их в индекс и затем сохраняет в репозитории.

0:02:39.720,0:02:45.560
Обратите внимание: если еще раз посмотреть "git status", то видно, что остальные изменения остались на своем месте,

0:02:45.560,0:02:47.560
то есть коммит работает только по указанному пути.

0:02:47.740,0:02:53.820
При этом действует то же ограничение как и для флага "-a": файлы, которые git не отслеживает, будут проигнорированы.

0:02:54.250,0:02:58.589
Так что если я, аналогично предыдущему примеру, добавлю файл "new.html"

0:02:59.140,0:03:03.680
и попробую вызвать "git commit" для него, то вот видно, ничего не прошло.

0:03:04.480,0:03:10.280
Итак, мы рассмотрели флаг "-a" для сохранения всех изменений, но лишь в проиндексированных файлах.

0:03:10.840,0:03:18.060
Дали указание коммиту путей, чтобы сохранить только их, но, опять же, это работает тоже только для проиндексированных файлов.

0:03:18.520,0:03:23.620
Иногда может возникнуть вопрос: "А почему только для проиндексированных?"
Но это очень просто.

0:03:23.880,0:03:27.580
Так сделано специально, чтобы ненароком не добавить в репозиторий что-нибудь лишнее.

0:03:27.910,0:03:32.340
Мало ли какой-нибудь временный файл или результат сборки. В жизни такое бывает.

0:03:32.860,0:03:38.999
Но, с другой стороны, иногда хочется просто закоммитить всё, что сделали, включая и не отслеживаемые файлы тоже.

0:03:39.790,0:03:46.409
Какого-то одного флага или какой-то одной команды git для этого не существует, но можно создать алиас, вот такой.

0:03:47.380,0:03:52.340
Использование очень простое: переходим в нужную директорию и вызываем "git commit --all"

0:03:52.340,0:03:57.820
И дальше можно параметры по вкусу. Они добавятся в конец алиса,
то есть для команды "git commit"

0:03:57.900,0:04:02.980
Соответственно, это добавит содержимое текущей директории в индекс и дальше вызовет "git commit"

0:04:02.980,0:04:08.520
Или для полноты картины еще одна разновидность этого рецепта: "git add -A"

0:04:09.120,0:04:15.020
Это очень редкий флаг. Если посмотреть на предыдущий вариант, то он добавит только текущую директорию.

0:04:15.140,0:04:19.780
К примеру, если перейти в поддиректорию srс, то точка будет означать именно её.

0:04:20.350,0:04:23.850
А "git add -A", откуда бы мы её не вызвали,

0:04:24.220,0:04:28.499
Добавить в индекс всегда вообще все изменения, начиная с корня проекта.

0:04:29.200,0:04:31.200
Раз - и всё проиндексировано.

0:04:31.820,0:04:38.520
И если взглянуть на "git status", то видно, что в индексе теперь как существующие файлы, так и новый, который ранее не отслеживался.

0:04:38.940,0:04:43.560
Соответственно, полный пример использования такого алиаса будет выглядеть так: "git commit --all"

0:04:43.560,0:04:46.440
и дальше какие-то дополнительные параметры для "commit".

0:04:46.440,0:04:52.520
Обратим внимание, что так, как я сейчас сделал, поступать обычно не следует, так как я просто взял все изменения,

0:04:52.780,0:04:55.440
смешал их в один большой commit и сохранил в git.

0:04:56.460,0:05:01.220
О разработчиках, которые так делают, иногда в шутку говорят что они используют git как машину времени.

0:05:01.380,0:05:06.740
Вернуться на заданный момент мы потом сможем, но разобраться в истории разработки будет очень затруднительно.

0:05:06.910,0:05:14.489
Тем не менее, если мы точно знаем, что изменения формируют хороший коммит, то почему бы нет. Вполне уместный алиас. Можно пользоваться.

0:05:15.340,0:05:19.360
Итак, мы рассмотрели три способа коммита без явного вызова "add".

0:05:20.030,0:05:27.069
Первый: флаг "-a" автоматически добавляет изменения из рабочей директории в коммит, но только для тех файлов, которые уже

0:05:27.350,0:05:33.699
отслеживаются git. Это удобно, когда мы зашли в проект с чистым статусом, что-то поменяли, чтобы быстро это закоммитить.

0:05:34.550,0:05:40.210
Второй: явно передать пути для "commit". Тогда он сделает то же самое, но лишь для указанных путей.

0:05:40.520,0:05:45.759
Это удобно, когда в проекте есть изменения, но мы хотим по-быстрому закоммитить один или несколько файлов.

0:05:46.340,0:05:48.340
Остальные пути он тогда не тронет.

0:05:48.830,0:05:54.370
И, наконец, если мы хотим добавлять и неотслеживаемые файлы тоже, то можно сделать алиас.

0:05:54.800,0:05:59.020
Такой для сохранения текущей директории и такой для всего проекта.

0:05:59.240,0:06:05.379
При этом, конечно, нужно аккуратно смотреть, чтобы не закоммитить лишнего, но в простых ситуациях такие команды могут быть удобны.
